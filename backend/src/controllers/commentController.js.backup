import Comment from "../models/Comment.js";
import Post from "../models/Post.js";

/**
 * Helper function to handle controller errors consistently
 * @param {Object} res - Express response object
 * @param {String} message - User-friendly error message
 * @param {Error} error - The error object
 */
const handleControllerError = (res, message, error) => {
  console.error(message, error);
  return res
    .status(500)
    .json({ success: false, message, error: error.message });
};

/**
 * Check if user can modify a comment (author or admin)
 * @param {Object} comment - The comment document
 * @param {Object} user - The authenticated user
 * @returns {Boolean} True if user can modify the comment
 */
const canModify = (comment, user) => {
  return (
    comment.author.toString() === user._id.toString() || user.role === "admin"
  );
};

/**
 * Validate and sanitize comment content
 * @param {String} content - Raw content from request
 * @returns {Object} { valid: boolean, sanitized: string, error: string }
 */
const validateCommentContent = (content) => {
  // Trim whitespace
  const trimmed = content?.trim();

  if (!trimmed) {
    return { valid: false, error: "Content cannot be empty" };
  }

  if (trimmed.length > 2000) {
    return {
      valid: false,
      error: "Content exceeds maximum length of 2000 characters",
    };
  }

  // Basic XSS prevention: remove script tags and dangerous attributes
  // For production, consider using a library like DOMPurify or sanitize-html
  const sanitized = trimmed
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")
    .replace(/on\w+="[^"]*"/gi, "")
    .replace(/on\w+='[^']*'/gi, "");

  return { valid: true, sanitized };
};

// Get comments for a post
export const getCommentsByPost = async (req, res) => {
  try {
    const { postId } = req.params;
    const { page = 1, limit = 50 } = req.query;

    // Parse pagination values explicitly to prevent string math bugs
    const pageNum = parseInt(page, 10) || 1;
    const limitNum = parseInt(limit, 10) || 50;
    const skip = (pageNum - 1) * limitNum;

    // Get top-level comments (no parent)
    const comments = await Comment.find({ post: postId, parentComment: null })
      .populate("author", "name")
      .sort("-createdAt")
      .skip(skip)
      .limit(limitNum);

    // Batch fetch all replies in a single query (eliminates N+1 problem)
    const commentIds = comments.map((c) => c._id);
    const replies = await Comment.find({ parentComment: { $in: commentIds } })
      .populate("author", "name")
      .sort("createdAt");

    // Group replies by parent comment ID
    const repliesByParent = replies.reduce((acc, reply) => {
      const parentId = reply.parentComment.toString();
      acc[parentId] = acc[parentId] || [];
      acc[parentId].push(reply);
      return acc;
    }, {});

    // Attach replies to their parent comments
    const commentsWithReplies = comments.map((comment) => ({
      ...comment.toObject(),
      replies: repliesByParent[comment._id.toString()] || [],
    }));

    const total = await Comment.countDocuments({
      post: postId,
      parentComment: null,
    });

    res.json({
      comments: commentsWithReplies,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        pages: Math.ceil(total / limitNum),
      },
    });
  } catch (error) {
    handleControllerError(res, "Error fetching comments", error);
  }
};

// Create comment
export const createComment = async (req, res) => {
  try {
    const { postId, parentCommentId } = req.body;

    // Validate and sanitize content
    const validation = validateCommentContent(req.body.content);
    if (!validation.valid) {
      return res.status(400).json({
        success: false,
        message: validation.error,
      });
    }

    // Verify post exists
    const post = await Post.findById(postId);
    if (!post) {
      return res.status(404).json({
        success: false,
        message: "Post not found",
      });
    }

    // Check if post is locked
    if (post.isLocked) {
      return res.status(403).json({
        success: false,
        message: "This post is locked and cannot accept new comments",
      });
    }

    // If it's a reply, verify parent comment exists
    if (parentCommentId) {
      const parentComment = await Comment.findById(parentCommentId);
      if (!parentComment) {
        return res.status(404).json({
          success: false,
          message: "Parent comment not found",
        });
      }
    }

    const comment = await Comment.create({
      content: validation.sanitized,
      post: postId,
      author: req.user._id,
      parentComment: parentCommentId || null,
    });

    const populatedComment = await Comment.findById(comment._id).populate(
      "author",
      "name"
    );

    res.status(201).json({
      success: true,
      comment: populatedComment,
    });
  } catch (error) {
    handleControllerError(res, "Error creating comment", error);
  }
};

// Update comment
export const updateComment = async (req, res) => {
  try {
    const comment = await Comment.findById(req.params.id);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Comment not found",
      });
    }

    // Check if user is authorized to update this comment
    if (!canModify(comment, req.user)) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to update this comment",
      });
    }

    // Validate and sanitize content if provided
    if (req.body.content) {
      const validation = validateCommentContent(req.body.content);
      if (!validation.valid) {
        return res.status(400).json({
          success: false,
          message: validation.error,
        });
      }

      comment.content = validation.sanitized;
      comment.isEdited = true;
      comment.editedAt = new Date();
    }

    await comment.save();

    const updatedComment = await Comment.findById(comment._id).populate(
      "author",
      "name"
    );

    res.json({
      success: true,
      comment: updatedComment,
    });
  } catch (error) {
    handleControllerError(res, "Error updating comment", error);
  }
};

// Delete comment
export const deleteComment = async (req, res) => {
  try {
    const comment = await Comment.findById(req.params.id);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Comment not found",
      });
    }

    // Check if user is authorized to delete this comment
    if (!canModify(comment, req.user)) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to delete this comment",
      });
    }

    // Delete all replies to this comment
    await Comment.deleteMany({ parentComment: comment._id });

    await comment.deleteOne();

    res.json({
      success: true,
      message: "Comment and replies deleted successfully",
    });
  } catch (error) {
    handleControllerError(res, "Error deleting comment", error);
  }
};

// Like/Unlike comment
export const toggleLikeComment = async (req, res) => {
  try {
    const comment = await Comment.findById(req.params.id);

    if (!comment) {
      return res.status(404).json({
        success: false,
        message: "Comment not found",
      });
    }

    // Check if user has already liked using proper ObjectId comparison
    const hasLiked = comment.likes.some((id) => id.equals(req.user._id));

    if (hasLiked) {
      // Unlike the comment
      comment.likes.pull(req.user._id);
    } else {
      // Like the comment
      comment.likes.addToSet(req.user._id);
    }

    await comment.save();

    res.json({
      success: true,
      likes: comment.likes.length,
      isLiked: !hasLiked,
    });
  } catch (error) {
    handleControllerError(res, "Error toggling like", error);
  }
};
