import User from "../models/User.js";

/**
 * Helper function to handle controller errors consistently
 * @param {Object} res - Express response object
 * @param {String} message - User-friendly error message
 * @param {Error} error - The error object
 */
export const handleControllerError = (res, message, error) => {
  console.error(message, error);
  return res.status(500).json({ success: false, message });
};

/**
 * Helper function to find a friend request by sender ID
 * @param {Object} user - User document with friendRequests array
 * @param {String} fromId - ID of the user who sent the request
 * @returns {Object|undefined} The friend request object if found
 */
const findFriendRequest = (user, fromId) => {
  return user.friendRequests.find(
    (request) => request.from.toString() === fromId.toString()
  );
};

/**
 * Send a friend request
 * POST /api/friends/request/:userId
 */
export const sendFriendRequest = async (req, res) => {
  try {
    const { userId } = req.params; // User to send request to
    const currentUserId = req.user._id; // Authenticated user

    // Validate: Can't friend yourself
    if (userId === currentUserId.toString()) {
      return res.status(400).json({
        success: false,
        message: "Cannot send friend request to yourself",
      });
    }

    // Fetch both users to perform all validations
    const [currentUser, targetUser] = await Promise.all([
      User.findById(currentUserId),
      User.findById(userId),
    ]);

    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: "Current user not found",
      });
    }

    if (!targetUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Check if already friends
    if (
      targetUser.friends.some(
        (id) => id.toString() === currentUserId.toString()
      )
    ) {
      return res.status(400).json({
        success: false,
        message: "Already friends with this user",
      });
    }

    // Check if request already exists (you → them)
    const existingRequest = findFriendRequest(targetUser, currentUserId);
    if (existingRequest) {
      return res.status(400).json({
        success: false,
        message: "Friend request already sent",
      });
    }

    // Check if target user has already sent a request to current user (them → you)
    const reverseRequest = findFriendRequest(currentUser, userId);
    if (reverseRequest) {
      return res.status(400).json({
        success: false,
        message:
          "This user has already sent you a friend request. Accept it instead.",
      });
    }

    // Add friend request atomically to prevent race conditions
    await User.updateOne(
      { _id: targetUser._id },
      {
        $addToSet: {
          friendRequests: { from: currentUserId, createdAt: new Date() },
        },
      }
    );

    res.json({
      success: true,
      message: "Friend request sent successfully",
    });
  } catch (error) {
    handleControllerError(res, "Failed to send friend request", error);
  }
};

/**
 * Accept a friend request
 * POST /api/friends/accept/:requestId
 */
export const acceptFriendRequest = async (req, res) => {
  try {
    const { requestId } = req.params; // The _id of the user who sent the request
    const currentUserId = req.user._id;

    // Find current user
    const currentUser = await User.findById(currentUserId);
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Find the friend request
    const friendRequest = findFriendRequest(currentUser, requestId);

    if (!friendRequest) {
      return res.status(404).json({
        success: false,
        message: "Friend request not found",
      });
    }

    // Check if already friends (shouldn't happen, but good to validate)
    const alreadyFriends = currentUser.friends.some(
      (id) => id.toString() === requestId.toString()
    );

    if (alreadyFriends) {
      return res.status(400).json({
        success: false,
        message: "You are already friends with this user",
      });
    }

    // Find the requester user first to ensure they exist
    const requester = await User.findById(requestId);
    if (!requester) {
      return res.status(404).json({
        success: false,
        message: "Requester user not found",
      });
    }

    // Use atomic operations to add friends and remove request
    // This prevents race conditions and ensures both operations succeed or fail together
    await Promise.all([
      // Add friend to current user's list and remove request
      User.updateOne(
        { _id: currentUserId },
        {
          $addToSet: { friends: requestId },
          $pull: { friendRequests: { from: requestId } },
        }
      ),
      // Add current user to requester's friends list
      User.updateOne(
        { _id: requestId },
        { $addToSet: { friends: currentUserId } }
      ),
    ]);

    res.json({
      success: true,
      message: "Friend request accepted",
    });
  } catch (error) {
    handleControllerError(res, "Failed to accept friend request", error);
  }
};

/**
 * Reject a friend request
 * POST /api/friends/reject/:requestId
 */
export const rejectFriendRequest = async (req, res) => {
  try {
    const { requestId } = req.params;
    const currentUserId = req.user._id;

    const currentUser = await User.findById(currentUserId);
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Find and remove the friend request
    const friendRequest = findFriendRequest(currentUser, requestId);

    if (!friendRequest) {
      return res.status(404).json({
        success: false,
        message: "Friend request not found",
      });
    }

    // Remove friend request atomically
    await User.updateOne(
      { _id: currentUserId },
      { $pull: { friendRequests: { from: requestId } } }
    );

    res.json({
      success: true,
      message: "Friend request rejected",
    });
  } catch (error) {
    handleControllerError(res, "Failed to reject friend request", error);
  }
};

/**
 * Get pending friend requests for current user
 * GET /api/friends/requests
 */
export const getFriendRequests = async (req, res) => {
  try {
    const currentUserId = req.user._id;

    const user = await User.findById(currentUserId).populate(
      "friendRequests.from",
      "name _id"
    );

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    res.json({
      success: true,
      requests: user.friendRequests,
    });
  } catch (error) {
    handleControllerError(res, "Failed to fetch friend requests", error);
  }
};

/**
 * Get friends list for a user
 * GET /api/friends/:userId
 */
export const getFriends = async (req, res) => {
  try {
    let { userId } = req.params;
    const currentUserId = req.user._id;

    // If userId is "me", use the authenticated user's ID
    if (userId === "me") {
      userId = req.user._id;
    }

    const user = await User.findById(userId).populate("friends", "name _id");

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Check if viewing own profile
    const isOwnProfile = userId.toString() === currentUserId.toString();

    // If not viewing own profile, check bidirectional friendship
    if (!isOwnProfile) {
      // Check if current user is in target user's friends list (they friended you)
      const isInTargetFriendsList = user.friends.some(
        (friend) => friend._id.toString() === currentUserId.toString()
      );

      // Also check if target user is in current user's friends list (you friended them)
      // This ensures bidirectional friendship for extra security
      const currentUser = await User.findById(currentUserId);
      const isInCurrentFriendsList = currentUser.friends.some(
        (id) => id.toString() === userId.toString()
      );

      // Both must be true for a valid friendship
      if (!isInTargetFriendsList || !isInCurrentFriendsList) {
        return res.status(403).json({
          success: false,
          message:
            "You must be friends with this user to view their friends list",
        });
      }
    }

    res.json({
      success: true,
      friends: user.friends,
      user: { name: user.name, _id: user._id },
    });
  } catch (error) {
    handleControllerError(res, "Failed to fetch friends", error);
  }
};

/**
 * Remove a friend
 * DELETE /api/friends/:friendId
 */
export const removeFriend = async (req, res) => {
  try {
    const { friendId } = req.params;
    const currentUserId = req.user._id;

    // Remove friend from current user's list
    const currentUser = await User.findById(currentUserId);
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Check if the user is actually in the friends list
    const isFriend = currentUser.friends.some(
      (id) => id.toString() === friendId.toString()
    );

    if (!isFriend) {
      return res.status(400).json({
        success: false,
        message: "This user is not in your friends list",
      });
    }

    // Remove friend from both users' lists atomically
    await Promise.all([
      User.updateOne({ _id: currentUserId }, { $pull: { friends: friendId } }),
      User.updateOne({ _id: friendId }, { $pull: { friends: currentUserId } }),
    ]);

    res.json({
      success: true,
      message: "Friend removed successfully",
    });
  } catch (error) {
    handleControllerError(res, "Failed to remove friend", error);
  }
};

/**
 * Get friendship status between current user and another user
 * GET /api/friends/status/:userId
 */
export const getFriendshipStatus = async (req, res) => {
  try {
    const { userId } = req.params;
    const currentUserId = req.user._id;

    // Can't check status with yourself
    if (userId === currentUserId.toString()) {
      return res.json({
        success: true,
        status: "self",
      });
    }

    // Fetch both users in parallel for better performance
    const [currentUser, targetUser] = await Promise.all([
      User.findById(currentUserId),
      User.findById(userId),
    ]);

    if (!targetUser) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    // Check if already friends (bidirectional check)
    if (currentUser.friends.some((id) => id.toString() === userId.toString())) {
      return res.json({
        success: true,
        status: "friends",
      });
    }

    // Check if current user has sent a request to target user
    const sentRequest = findFriendRequest(targetUser, currentUserId);
    if (sentRequest) {
      return res.json({
        success: true,
        status: "pending_sent",
      });
    }

    // Check if target user has sent a request to current user
    const receivedRequest = findFriendRequest(currentUser, userId);
    if (receivedRequest) {
      return res.json({
        success: true,
        status: "pending_received",
      });
    }

    // No relationship
    res.json({
      success: true,
      status: "none",
    });
  } catch (error) {
    handleControllerError(res, "Failed to check friendship status", error);
  }
};

/**
 * Cleanup friend data when a user account is deleted
 * This utility function should be called when deleting a user account
 * @param {String} deletedUserId - The ID of the user being deleted
 */
export const cleanupFriendDataOnUserDelete = async (deletedUserId) => {
  try {
    // Remove the deleted user from all friends lists and friend requests
    await User.updateMany(
      {},
      {
        $pull: {
          friends: deletedUserId,
          friendRequests: { from: deletedUserId },
        },
      }
    );

    console.log(`Cleaned up friend data for deleted user: ${deletedUserId}`);
  } catch (error) {
    console.error("Error cleaning up friend data:", error);
    throw error;
  }
};
